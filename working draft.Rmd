---
title: "Week12"
author: "Ashley Hirt, Shreya Dubey, Rakib Kamal"
date: "11/18/2019"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library Packages

```{r}
library(data.table)
library(tidyverse)
library(viridis)
theme_set(theme_minimal())

# colors used for plotting
mygreen <- "#22908C"
mypurple <- "#450D54"
```

## Read in Data

First, we read in our data and the columns. We will also get rid of Discharge.Year because all of the years were 2016.
```{r read data}
ashley <- "G:/My Drive/DATA/Final Project/hospital.csv"
rakib <- "C:\\Users\\Rakib Kamal\\Box Sync\\Fall 2019\\DS4001\\Projects\\Final\\hospital.csv"

hosp <- fread(ashley, 
              check.names=T,
              na.strings = c("", "NA")
)

hosp <- as.tibble(hosp)
# save original dataset before renaming
hosp_og <- hosp

# rename columns
colnames(hosp) <- c("Area", "County", "Certificate", "Facility.ID", "Facility.Name",
                    "Age", "Zip", "Gender", "Race", "Ethnicity", "Duration", "Type",
                    "Discharge.Status", "Discharge.Year", "CCS.Code", "CCS.Diagnosis",
                    "CCS.Procedure.Code", "CCS.Procedure", "DRG.Code", "DRG",
                    "MDC.Code", "MDC", "Severity.Code", "Severity", "Mortality.Risk",
                    "Surgical", "Payment1", "Payment2", "Payment3", "Birthweight",
                    "Abortion", "ED", "Charges", "Costs")

unique(hosp$Discharge.Year)
# get rid of discharge.year 
hosp <- hosp[,-which(colnames(hosp)=="Discharge.Year")]
```

## Examine Existing NAs
Then, we examine existing NAs. We see that, of our 2,343,429 rows, there are 1,725,198 incomplete cases. Please note that in any cases where we think there could be systematic missingness in categorical variables, we are keeping the variables as "unknown" or "not applicable" rather than recoding them as NAs. This is because randomForest removes any rows with NAs or forces you to impute them; instead, we'd like to keep them as a separate grouping. For continuous variables, we are recoding them as NAs to avoid introducing strings into a numeric variable.
```{r examine existing NAs}
sum(complete.cases(hosp) == F) # 1725198 incomplete cases

# to look at the incomplete rows (assign data frame "incomplete"):
incomplete <- hosp[!complete.cases(hosp),]

# tally up the number of NAs in each column
nas <- c()
invisible(
sapply(1:ncol(incomplete), function(x) {
  nas[x] <<- sum(is.na(incomplete[,x]))
})
)
names(nas) <- colnames(incomplete)
nas # shows the number of NAs in each column
```
Area, County, Certificate, and Facility.ID have 5325 instances of NAs. They all co-occur (an NA in one of these variables corresponds to an NA in the others as well). We also see that the Facility.Name variable is always "Redacted for Confidentiality" for these instances. Presumably, this is the reason that all the location information is NAs for these records.
```{r}
unique(incomplete[is.na(incomplete$Area),]$Facility.Name)
```
Zipcode has 36215 NAs. The data dictionary states that the patient zip code will be blank (NA) for the following confidentiality reasons: zip code population size less than 20,000 people; abortion records; less than 10 records with that zip code.


Severity AND Mortality.Risk each have 67 NAs, which also co-occur. Most of these records have no diganosis under the DRG column and they have a DRG.Code greater than 952. This doesn't make sense, since the maximum DRG.Code used in New York State is 952. Thus, we assume these records had missing or invalid DRG Codes. Since Severity and mortality.risk are derived from the DRG coding system as well, it makes sense that they would also be NAs. Also, (inexplicably), for all of these records, the CCS.Diagnosis corresponds to some type of birth that was not an abortion.
```{r}
# examine incomplete severity rows
severity.incomplete <- incomplete[is.na(incomplete$Severity),]
unique(severity.incomplete$DRG.Code)
unique(severity.incomplete$DRG)

# replace with NAs
hosp$DRG.Code <- ifelse(hosp$DRG.Code > 952, NA, hosp$DRG.Code)
```


Payment2 has 834420 NAs. Payment3 has 1691076 NAs. These correspond to people that only had one or two payment types, respectively, so that makes sense and requires no further investigation.


## Change Invalid Values to NAs
To identify invalid values in each of our variables, we look at their distributions (either a histogram for quantitative variables or bar plots for categorical variables). 
```{r}
# examine birthweight plot for strange values
ggplot(hosp, aes(x=Birthweight)) +
  geom_histogram() + 
  ggtitle("Distribution of Birthweight (g)") +
  ylab("Number of Admissions") +
  xlab("Birthweight (g)")
```
We see that there are a large number of 0s for birthweight, which indicates that the record does not correspond to a pregnancy/birth. We replace all 0s with "Not a birth", reexamine the birthweight plot, and see that it appears normal (as expected)

```{r}
hosp$Birthweight <- ifelse(hosp$Birthweight==0, NA, hosp$Birthweight)

# reexamine birthweight plot
ggplot(hosp, aes(x=Birthweight)) +
  geom_histogram() + 
  ggtitle("Distribution of Birthweight (g)") +
  xlab("Birthweight (g)") +
  ylab("Number of Admissions")
# none of the birthweights appear abnormal (they do follow a normal distribution)
```

Repeat for gender, and replace all 57 "U" genders with "Unknown".  
```{r}
# examine gender plot for unusual values
ggplot(hosp, aes(x=Gender)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Gender") +
  xlab("Gender") +
  ylab("Number of Admissions")
# replace all "U" genders with "Unknown"
sum(hosp$Gender == "U") # only 57 records with unknown gender.
hosp$Gender <- ifelse(hosp$Gender=="U", "Unknown", hosp$Gender)
```

Repeat for ethnicity, and keep all 97,000+ "unknown" ethnicities. 
```{r}
# examine ethnicity plot for unusual values
ggplot(hosp, aes(x=Ethnicity)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Ethnicity") +
  xlab("Ethnicity") +
  ylab("Number of Admissions")
# look at number of unknown ethnicities
sum(hosp$Ethnicity == "Unknown") # 97,180 records with Unknown ethnicities
```

Repeat for surgical, and replace all 67 "Not Applicable" entries with "Unknown"
```{r}
# examine categories
ggplot(hosp, aes(x=Surgical)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Surgical Category") +
  xlab("Surgical Category") +
  ylab("Number of Admissions")
# replace surgical "Not Applicable" entries with "Unknown"
sum(hosp$Surgical == "Not Applicable") # 67 Surgery "Not Applicable"s
hosp$Surgical <- ifelse(hosp$Surgical=="Not Applicable", "Unknown", hosp$Surgical)
```

Repeat for Type of Admission, and replace any Unavailable values with "Unknown"
```{r}
ggplot(hosp, aes(x=Type)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Type of Admission") +
  xlab("Type of Admission") +
  ylab("Number of Admissions")
sum(hosp$Type=="Not Available") # 435 of these rows
hosp$Type <- ifelse(hosp$Type == "Not Available", "Unknown", hosp$Type)
```

Repeat for discharge status, and replace unavailable values with "Unknown."
```{r}
ggplot(hosp, aes(x=Discharge.Status)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Discharge Status") +
  xlab("Type of Discharge Status") +
  ylab("Number of Admissions") +
  theme(axis.text.x = element_text(angle=90, vjust=.5)) +
  scale_x_discrete(label=function(x) abbreviate(x, minlength=22))

sum(hosp$Discharge.Status=="Another Type Not Listed") #6976 "Another Type"s
hosp$Discharge.Status <- ifelse(hosp$Discharge.Status=="Another Type Not Listed", 
                                "Another Type", hosp$Discharge.Status)
```

Repeat for CCS code. From the distribution, we see that categories above 650-663 and 670 represent MHSA coding (mental health codes). 917 stands for unclassified E code and 999 is ungroupable, which we will recode as NAs
```{r}
ggplot(hosp, aes(x=CCS.Code)) + 
  geom_histogram() +
  ggtitle("Distribution of CCS Codes") +
  xlab("CCS Code") +
  ylab("Number of Admissions")

#recode as NAs  
hosp$CCS.Code <- ifelse(hosp$CCS.Code==999, NA, hosp$CCS.Code)
```

Repeat for payment1. We will keep the 6,896 "Unknowns." Note that we are not replacing payment2 or payment3 "Unknown" with NA because currently, NA stands for "there was not a second/third payment type" and we don't want to combine these records. Perhaps the unknown category has predictive value and should be kept separate from the other NAs. 
```{r}
# replace payment1 "Unknown" with NA
sum(hosp$Payment1 == "Unknown") #6896 Payment1 "Unknown"
```

## Examine Distributions of Variables
Next, we examine the distributions of our variables to get an idea of whether they appear appropriate.
```{r examine distributions}
ggplot(hosp, aes(x=Area)) + 
  geom_bar(stat="count") + 
  theme(axis.text.x = element_text(angle = 45, size=8, vjust=.8)) +
  ggtitle("Distribution of Admissions by Hospital Service Area") +
  xlab("Area") +
  ylab("Number of Admissions")
```
This plot looks appropriate, and shows that most admissions come from New York City.

Next, we examine the distribution of county, adding in population data to see if the percent of total admissions for a county matches the percent of NY state population for each county. (We would expect that they should be close to eachother, if not equal.)
```{r}
# get percent of admissions by county
hosp %>%
  count(County) %>%
  mutate(perc = n/ nrow(hosp)) -> hosp2

# load in new york population data
ashley4 <- "C:/Users/Ashley Hirt/Documents/GitHub/FinalProject/county-pops.csv"
countypops <- read.csv(ashley4, header=T)

# left outer join of % admissions (hosp2) and population data (countypops) per county
hosp3 <- merge(hosp2, countypops, by="County", all=T)

# graph admissions by county with new york population data.
mycolors <- c("Number of Admissions" = mygreen, 
               "Population" = mypurple)

ggplot(hosp3, aes(x=reorder(County, -n), y=perc)) + 
  geom_bar(aes(fill="Number of Admissions"), stat="identity", alpha=.5) +
  geom_bar(aes(y=prop.of.NY, fill="Population"), 
             stat="identity", alpha=.5) +
  # geom_point(aes(y=prop.of.NY, fill="Population", color="Population"), 
  #            shape=21, stat="identity", alpha=.5) +
  theme(axis.text.x = element_text(angle = 90, size=8, vjust=0.2),
        legend.position=c(.8,.8),
        legend.background = element_rect(fill="white", color="grey")) +
  scale_fill_manual(name=NULL, values=mycolors, 
    labels=c("Admissions \n (% of Total)", "Population \n (% of NY State Total)"),
    aesthetics=c("fill", "color")) +
  ggtitle("Percent of Admissions by County, compared to \n Percent of NY Population by County") +
  xlab("County") +
  ylab("Number (% of Total)") +
  scale_y_continuous(labels=scales::percent)
```
From the above graph, we see that the green bar represents the percent of our dataset's total admissions that come from each county. The light purple bar shows the population of each county, represented as a percent of NY state's total population. Since our dataset ideally represents all of New York state, we would expect the two percentages to be equal (in the absence of any other influential factors). However, we see that some counties (notably, Manhattan, Nassau, Monroe, Onondaga, and Albany) disproportionately represent higher hospital admissions than their population numbers would predict. On the other hand, Kings, Queens, and Saratoga counties represent less of all hospital admissions than would be expected by their populations. 

This could indicate disproportionate usage of the healthcare system by some counties over others. However, it could also indicate problems in the collection of our dataset (e.g., perhaps most hospitals sampled were in Manhattan and not evenly spread across all counties). 



Next, we examine how cerficate compares to facility.name and facility.ID (are they redundant?).
```{r}
name <- list()
id <- list()

# group by certificate, then get the unique facility name/ID with that certificate
x <- hosp %>%
  group_by(Certificate) %>%
  summarise(
    name = list(unique(Facility.Name)),
    id = list(unique(Facility.ID))
  )
x$name[c(1:10)]

```
From this, we see that there are multiple hospital names for the same certificate number, but they are typically different campuses of the same main hospital (e.g. "Albany Medical Center Hospital" and "Albany Medical Center - South Clinical Campus"). The facility ID corresponds to these campus differences. So we assume that in our classification tasks, we will not use certificate or facility.name, we'll just use facility.ID because it encapsulates the former two variables.

```{r}
# examine distribution of facility ID
ggplot(hosp, aes(x=Facility.ID)) + 
  geom_histogram() +
  ggtitle("Distribution of Facility ID")
```
It appears unusual that some facility IDs are in the 9000s, but this is not mentioned in our data dictionary, so there is no way to know if they are valid or not.

```{r}
high.id <- filter(hosp, Facility.ID>9000)
unique(high.id$Area)
unique(high.id$Facility.Name)
```
Examination of these rows indicates there are 3,151 rows with facility.ID>9000. They all come from one of 3 hospitals: St Peter's Addiction Recovery Center, The Burdett Care Center, and Crouse Hospital - Commonwealth Division. Although their facility.ID values seem unusual, these records do appear valid, so we keep them in the dataset unchanged.

After performing this analysis, we drop the facility.name and certificate rows, but keep the Facility.ID variable.
```{r}
# drop columns Facility.Name and certificate
hosp <- hosp[,-which(colnames(hosp) %in% c("Certificate", "Facility.Name"))]
```

Next, we examine a distribution of age groups.
```{r}
ggplot(hosp, aes(x=Age)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Age Group")
```
This appears normal, no NAs. Age groups 50-69, and 70+ have the highest amount of hospital discharge records, which is consistent with what is expected.

```{r}
ggplot(hosp, aes(x=Race)) + 
  geom_bar(stat="count") +
  ggtitle("Distribution of Race")
```
The distribution of race also appears normal, no NAs. Note that "other race" is explained in the data dictionary as coding for Asians, Pacific Islanders, and Native Americans.

```{r}
y <- hosp %>% group_by(Duration) %>% summarize(count = n())
ggplot(y, aes(x=as.numeric(Duration), y=count)) + 
  geom_point() +
  ggtitle("Distribution of Duration of Hospital Stay")
```
Here we see that the vast majority of Hospital durations are less than 10 days. Also, the one row that was removed was "120+" bc it is not easily coerced to numeric. We know a priori from the data dictionary that this categorization of duration stands for any duration greater than 120 days.

## Examine Predictors of Charges
```{r}
ggplot(hosp, aes(x=Area, y=Charges)) +
  geom_boxplot() +
  coord_cartesian(ylim=c(0, 150000)) +
  ggtitle("Distribution of Charges based on Hospital Service Area") +
  theme(axis.text.x = element_text(angle = 45, size=8, vjust=.8)) +
  xlab("Area") +
  ylab("Charges ($)") +
  geom_hline(yintercept=median(hosp$Charges), color="navy blue", linetype="dashed", size=1)
```

## Create indicator variables
For all values replaced with NAs or other abnormalities noted above, we will create indicator variables in case there is systematic missingness.
```{r}
hosp <- hosp %>%
  mutate(redacted = ifelse(is.na(hosp$Area), 1, 0),
         na.zip = ifelse(is.na(Zip), 1, 0),
         invalid.drg = ifelse(is.na(DRG.Code), 1, 0),
         na.payment1 = ifelse(Payment1=="Unknown", 1, 0),
         no.payment2 = ifelse(is.na(Payment2), 1, 0),
         unknown.payment2 = ifelse(Payment2=="Unknown", 1, 0),
         no.payment3 = ifelse(is.na(Payment3), 1, 0),
         unknown.payment3 = ifelse(Payment3 == "Unknown", 1, 0),
         if.birth = ifelse(is.na(Birthweight), 0, 1),
         na.gender = ifelse(is.na(Gender), 1, 0),
         na.ethnicity = ifelse(is.na(Ethnicity), 1, 0),
         na.surgical = ifelse(is.na(Surgical), 1, 0),
         high.id = ifelse(Facility.ID > 9000, 1, 0),
         na.type = ifelse(is.na(Type), 1, 0),
         na.discharge = ifelse(is.na(Discharge.Status), 1, 0),
         na.ccs = ifelse(is.na(CCS.Code), 1, 0),
         na.ccs.procedure = ifelse(is.na(CCS.Procedure.Code), 1, 0),
         na.mdc = ifelse(is.na(MDC.Code), 1, 0)
         )
```


# Test Center
```{r}
ggplot(hosp, aes(x=Type)) + geom_bar(stat="count")
ggplot(hosp, aes(x=Discharge.Status)) + geom_bar(stat="count") + theme(axis.text.x = element_text(angle=90))



# THIS STILL NEEDS TO BE ADDED IN 
ggplot(hosp, aes(x=CCS.Procedure.Code)) + geom_histogram()
# the highest CCS Procedure code is 231. 
unique(hosp[hosp$CCS.Procedure.Code>231, "CCS.Procedure.Code"])
# all the records greater than 231 are coded 999 for ungroupable, so we will make those NAs.
hosp$CCS.Procedure.Code <- ifelse(hosp$CCS.Procedure.Code==999, NA, hosp$CCS.Procedure.Code)
# there are also 0s in the procedure code, which correponds to no procedure performed. we will create an indicator variable for those later.
hosp[hosp$CCS.Procedure.Code==0, c("CCS.Procedure.Code", "CCS.Procedure")][1,]


# ADD IN
hosp$Duration <- ifelse(hosp$Duration == "120 +", 120, hosp$Duration)
hosp$Duration <- as.numeric(hosp$Duration)


# ADD IN
# 0s don't make sense for Severity.Code and correspond to the redacted rows. 
hosp$Severity.Code <- ifelse(hosp$Severity.Code==0, NA, hosp$Severity.Code)


# ADD IN
nrow(hosp[hosp$MDC.Code==0,]) 
# 14 rows correspond to an MDC.Code of 0, representing an MDC of "Pre-MDC or Ungroupable". We will recode those MDC.codes as NAs.
hosp$MDC.Code <- ifelse(hosp$MDC.Code==0, NA, hosp$MDC.Code)



library(corrplot)
hosp$Duration <- as.numeric(hosp$Duration)
num <- hosp[,c("Duration", "CCS.Code", "CCS.Procedure.Code", "DRG.Code", "MDC.Code", "Severity.Code", "Birthweight", "Charges", "Costs")]

x <- cor(num[complete.cases(num)==T,])
corrplot(x)
# from the corrplot, we see that DRG.Code and MDC.Code are highly correlated. This is surprising, considering that there are only 26 MDC codes which correspond to organ systems, while there are 300+ DRG Codes that represent specific diseases. We also see that there is a moderate positive correlation between Severity.Code and Duration, which makes sense since Severity.Code is on a 1-4 scale with 4 being extremely severe. Also, there is a moderate negative correalation between birthweight and Duration (again as expected, these likely represent premature babies). There is a strong positive correlation between charges and duration, as well as costs with duration and costs with charges. Finally, there is a weak negative correlation between birthweight and severity.code, a weak postivie correlation of severity.code with costs and severity.code with charges, and a weak negative association between birthweight and charges/costs.

# I am surprised to see the signifcance that birthweight has as a predictor for our other variables. Specifically, we can draw some preliminary conclusions: the lower the birthweight, the higher the duration, the higher the severity.code, and the higher the charges/costs.
births <- hosp[hosp$Birthweight>0 & !is.na(hosp$Birthweight),]

ggplot(births[!is.na(births$Severity.Code),], aes(
  x=as.factor(Severity.Code), y=Birthweight)
  ) +
  geom_boxplot(colour=mygreen)

ggplot(births, aes(x=Birthweight, y=Duration)) + 
  geom_point(alpha=.3)

ggplot(births, aes(x=Birthweight, y=Charges)) +
  geom_point(alpha=.3)
ggplot(births, aes(x=Birthweight, y=Charges)) +
  geom_point(alpha=.3) +
  ylim(0, 2500000) # to cut out outliers

ggplot(births, aes(x=Birthweight, y=Costs)) +
  geom_point(alpha=.3)
ggplot(births, aes(x=Birthweight, y=Costs)) +
  geom_point(alpha=.3) +
  ylim(0, 1000000) # to cut out outliers




durs <- hosp %>%
  group_by(MDC.Code) %>%
  summarise(
    dur = median(Duration, na.rm=T),
    cost = mean(Costs),
    charge = median(Charges)
  ) %>%
  arrange(desc(dur))

ggplot(hosp, aes(x=as.factor(MDC.Code), y=Duration)) +
  geom_boxplot(outlier.shape=NA) +
  geom_text(data = durs, aes(x = as.factor(MDC.Code), y = dur, label = dur), 
              size = 3.5, vjust = -.3, color=mygreen) +
  coord_cartesian(ylim=c(0, 25)) +
  scale_x_discrete(limits = c("2", "12", "13", "17", "18", "19", "22", "23", "24", "25")) +
  xlab("MDC Code") +
  ylab("Duration of Admission (days)") +
  ggtitle("Comparison of the Distribution of Admission Duration between MDC Codes")
# only choosing to output durations that seem different from the norm of 3 or so days.

# 2, 12, 13 have lower durations and fewer high outliers. 17-19, and 22-25 have higher average durations. We also see this played out in their averages.

# just show a couple and show the median. 
colnames(hosp)
ggplot(hosp, aes(x=as.factor(MDC.Code), y=Charges)) +
  geom_boxplot(outlier.shape=NA) +
  coord_cartesian(ylim=c(0,250000)) +
  xlab("MDC Code") +
  ylab("Charges ($)") +
  #ggtitle("Comparison of the Distribution of Charges between MDC Codes") +
  scale_x_discrete(limits=c("8", "14", "15", "17", "18", "20", "22", "25")) +
  geom_hline(yintercept=median(hosp$Charges), color="navy blue", linetype="dashed", size=1) +
  theme(plot.title = element_text(color="navy blue"))

  
hosp %>%
  group_by(MDC.Code) %>%
  summarise(
    k=unique(MDC)
  )

hosp$chargeratio <- hosp$Charges / hosp$Costs

ggplot(hosp, aes(x=Charges, y=Costs)) + 
  geom_point(alpha=.3)

ggplot(hosp, aes(x=chargeratio)) +
  geom_histogram() +
  xlim(0, 20) # cut out outliers

sapply(1:25, function(x) {
ggplot(filter(hosp, MDC.Code==13), aes(x=chargeratio)) +
  geom_histogram(bins=15, fill="white", color="black") +
  xlim(0,10) +
  geom_vline(xintercept=median(hosp$chargeratio), linetype="dashed", color="navy blue", size=1) +
  xlab("Ratio of Charges to Costs") +
  ylab("Number of Admissions") +
  #ggtitle("Distribution of Charge Ratio") +
  scale_y_continuous(labels=scales::comma) +
  facet_wrap(MDC.Code~.)
})
# This distribution is obviously right-skewed, with a median of around 2. 
# note removal of rows with 0 cost are being removed.

ggplot(hosp, aes(x=chargeratio)) +
  geom_histogram(bins=15, fill="white", color="black") +
  xlim(0,10) +
  geom_vline(xintercept=median(hosp$chargeratio), linetype="dashed", color="navy blue", size=1) +
  xlab("Ratio of Charges to Costs") +
  ylab("Number of Admissions") +
  #ggtitle("Distribution of Charge Ratio") +
  scale_y_continuous(labels=scales::comma)

median(hosp$chargeratio)

# make all non-numeric columns into factors
num.index <- c()
for (i in 1:length(colnames(num))) {
  num.index[i] <- which(colnames(num)[i] == colnames(hosp))
}
factor.index <- (1:ncol(hosp))[-num.index]
invisible(apply(hosp[,factor.index], 2, as.factor))
```

```{r}
# feature engineering


# median income for the diff zipcodes
# read in income file
rakib2 <- "C:\\Users\\Rakib Kamal\\Documents\\GitHub\\FinalProject\\zipcodes - Sheet1.csv"
ashley2 <- "C:/Users/Ashley Hirt/Documents/GitHub/FinalProject/zipcodes - Sheet1.csv"
incomes <- read.csv(file=ashley2)
colnames(incomes)[1] <- "Zip" # rename zip.code column
# perform left outer join on our hosp dataset and the income dataset, by Zipcode
hosp <- merge(hosp, incomes, by="Zip", all=T)
# rename the median income column
colnames(hosp)[which(colnames(hosp)=="Median.Income..family.")] <- "Median.Income"


# number of payment types
hosp <- hosp %>%
  mutate(numpay = case_when(
    is.na(Payment2) & is.na(Payment3) ~ 1,
    !is.na(Payment2) & is.na(Payment3) ~ 2,
    !is.na(Payment2) & !is.na(Payment3) ~ 3
  ))

# self-pay indicator
hosp <- hosp %>%
  mutate(selfpay = case_when(
    Payment1 == "Self-Pay" ~ 1,
    Payment2 == "Self-Pay" ~ 1,
    Payment3 == "self-Pay" ~ 1,
    TRUE ~ 0
  ))

# Birthweight find cutoffs
hosp <- hosp %>%
  mutate(birthweight.cat = case_when(
    Birthweight < 2500 & Birthweight > 1500 ~ "Low",
    Birthweight <= 1500 & Birthweight > 1000 ~ "Very Low",
    Birthweight <= 1000 ~ "Extremely Low",
    TRUE ~ "Normal"
  ))

# average cost for each prodedure? https://www.hcup-us.ahrq.gov/reports/statbriefs/sb154.jsp

# overall grouping for each procedure (https://www.hcup-us.ahrq.gov/reports/statbriefs/sb154.jsp app
procs <- hosp %>%
  group_by(CCS.Procedure.Code) %>%
  summarise(
    proc = unique(CCS.Procedure)
  ) %>%
  select(CCS.Procedure.Code, proc)

hosp <- hosp %>%
  mutate(CCS.Procedure.Group = case_when(
    CCS.Procedure.Code %in% c(1:9, 199, 188) ~ "Nervous System",
    CCS.Procedure.Code %in% c(10:12) ~ "Endocrine System",
    CCS.Procedure.Code %in% c(13:21, 220) ~ "Eyes",
    CCS.Procedure.Code %in% c(22:33) ~ "ENT",
    CCS.Procedure.Code %in% c(34:42, 216:217, 208) ~ "Respiratory System",
    CCS.Procedure.Code %in% c(43:63, 201:203, 205, 225, 189:191, 193, 204) ~ "Cardiovascular System",
    CCS.Procedure.Code %in% c(64:67, 222, 228) ~ "Hemic and Lymphatic System",
    CCS.Procedure.Code %in% c(69:99, 194, 223, 184:186, 221) ~ "Digestive System",
    CCS.Procedure.Code %in% c(100:112, 195, 187, 200) ~ "Urinary System",
    CCS.Procedure.Code %in% c(113:118) ~ "Male Genital Organs",
    CCS.Procedure.Code %in% c(119:123) ~ "Female Genital Organs",
    CCS.Procedure.Code %in% c(124:141) ~ "Obstetrical Procedures",
    CCS.Procedure.Code %in% c(142:164, 207, 212:215, 230) ~ "Musculoskeletal",
    CCS.Procedure.Code %in% c(165:175, 182) ~ "Integumentary System and Breast",
    CCS.Procedure.Code %in% c(176:181, 192, 183, 219, 218, 197, 198, 209, 210, 196, 211, 226, 227, 229, 231, 224) ~ "Misc or Diagnostic",
    CCS.Procedure.Code == 0 ~ "Ungroupable",
    is.na(CCS.Procedure.Code) ~ "No Procedure"
  ))


# read in county data
rakib3 <- "C:\\Users\\Rakib Kamal\\Documents\\GitHub\\FinalProject\\county.csv"
ashley3 <- "C:/Users/Ashley Hirt/Documents/GitHub/FinalProject/county.csv"
county <- read.csv(ashley3)
# left outer join with county data
hosp <- merge(hosp, county, by="County", all=T)

```

Test/Train split
```{r}
library(caret)
library(tidyverse)
set.seed(101)
index <- sample(1:nrow(hosp), .8*nrow(hosp))

# make character columns into factors
hosp$Severity.Code <- as.factor(hosp$Severity.Code)
hosp$Age <- as.factor(hosp$Age)
hosp$Gender <- as.factor(hosp$Gender)
hosp$Race <- as.factor(hosp$Race)
hosp$Ethnicity <- as.factor(hosp$Ethnicity)

num.index <- c()
for (i in 1:length(colnames(num))) {
  num.index[i] <- which(colnames(num)[i] == colnames(hosp))
}
factor.index <- (1:ncol(hosp))[-num.index]

factorize <- function(x) {
  hosp[[x]] <<- as.factor(hosp[[x]])
}
sapply(colnames(hosp)[factor.index], function(x) {
  hosp[,factor.index][x] <<- factorize
})


samp <- hosp[sample(1:nrow(hosp), 10000),]

train <- hosp[index,]
test <- hosp[-index,]
```

Random Forest Model
```{r}
library(randomForest)
library(tidyverse)


features <- samp %>% 
  select("Charges", "Costs", "Duration", "Severity.Code", 
         "Age", "Gender", "Race", "Ethnicity", "Zip", "Area", "Type", "Discharge.Status",
         "CCS.Code", "CCS.Procedure.Code", "DRG.Code", "MDC.Code", "MDC", "Mortality.Risk",
         "Surgical", "Payment1", "Payment2", "Payment3", "Abortion", "ED",
         "redacted", "na.zip", "invalid.drg", "na.payment1", "no.payment2", "birthweight.cat",
         "if.birth")

uniques <- sapply(apply(hosp, 2, unique), length)
uniques
uniques.samp <- sapply(apply(samp, 2, unique), length)
uniques.samp


apply(apply(features, 2, is.na), 2, sum)

fit <- randomForest(formula=Charges~., 
                    data=features,
                    ntree=50,
                    importance=T,
                    na.action=na.omit)
fit
library(caret)
varImp(fit)
varImpPlot(fit, type=2)
```

